#### 🔗 Link

﻿https://school.programmers.co.kr/learn/courses/30/lessons/12905

## 🤔 Think 

 DP의 기본같은 문제입니다. 이런 유형의 문제는 하도 많이 만나서 별 생각 없이 DP로 접근했네요.

 DP로 해결하는 원리는 [링크](https://minnnne.tistory.com/16)에서 참고하시면 됩니다. 그림으로 쉽게 설명해놓으셔서 링크 남겨놓습니다.

## 🔎 Solve
- 2 * 2 이상의 크기의 배열을 상정하고 반복문을 돕니다. 1 * 1이라면 애초에 반복문에 들어가지 않습니다.
- [1, 1] 칸부터 [N ,N] 칸까지를 순회하며 만일 [i, j] 칸이 1이라면 자신의 좌상단, 상단, 좌측 칸의 최솟값을 찾습니다.
  - 0인 경우에는 어짜피 0이 들어갑니다. 해당 칸을 이용해서 만들 수 있는 정사각형은 없기 때문입니다.
- 찾은 최솟값에 1을 더해 해당 칸을 활용해 만들 수 있는 가장 큰 정사각형의 길이를 구합니다.
- DP가 적용된 배열을 순회하며 최댓값을 찾고 이를 제곱하여 반환합니다.
