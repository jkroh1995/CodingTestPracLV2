#### 🔗 Link

https://school.programmers.co.kr/learn/courses/30/lessons/118667

## 🤔 Think 
 두 큐의 합을 같게 만드는 방법은 쉽습니다. 실제로 왔다갔다 해보면 되니까요. 그래봐야 O(N)의 시간복잡도 내에서 해결할 수 있습니다.

 문제는 '두 큐의 합이 영원히 같아지지 않는 경우'를 어떻게 해결할 것인가? 입니다. 두 큐의 합이 영원히 같아지지 않는 경우는 크게 세 가지가 있습니다.

1. 큐 중 어느 하나의 값이 두 큐의 값을 합친 것의 절반보다 클 경우 : 이 경우 해당 값이 들어간 큐가 다른 모든 숫자들이 들어간 큐보다 합이 커질 수밖에 없습니다.
2. 두 큐의 모든 수의 합이 홀수일 경우 : 어느 한 큐는 반드시 다른 큐보다 합이 클 수밖에 없습니다.
3. 진짜로 모든 경우에서 답이 안나오는 경우

 위의 두 가지 경우를 처리하는 것은 쉽습니다. 문제는 마지막 경우를 어떻게 처리하느냐입니다.

 제가 생각한 방법은 최악의 최악의 경우에는 몇 번의 이동만에 두 큐의 합이 같아지는지를 파악해 그 횟수가 넘어가면 답이 나올 수 없다고 결론내리는 것이었습니다.

 최악의 경우는 어느 한 큐의 마지막에서 두 번째 숫자가 다른 모든 숫자들의 합과 같은 경우입니다. 예를 들어 볼까요?

- 1번 큐에는 n 개의 1이 담겨있습니다.
- 2번 큐에는 n-2개의 1이 담겨있고, n-1번째에는 남은 모든 1을 합친 값이, n번째에는 1이 담겨있습니다.
- 이 때 n-1번째 원소의 값은 n + (n-2) + 1 = 2n-1 이 됩니다.
- 2n-1이 첫 번째 큐에 넘어가기 전까지는 무조건 첫 번째 큐의 합이 더 작습니다. 따라서 2n-1까지 2번 큐의 숫자를 1번 큐로 넘겨야합니다. 이 때 n-1번의 숫자 이동이 발생합니다.
- 이제 첫 번째 큐의 마지막 원소가 2n-1이 되었습니다. 앞에 있는 모든 1을 2번 큐로 넘기면 두 큐의 합이 드디어 같아지겠네요. 기존의 n개에 추가된 n-2개(마지막 숫자는 남겨야함)까지 총 2n-2번의 숫자 이동이 발생합니다.
- 즉, 최악의 경우에는 3n-3번의 이동이 발생합니다.

 이렇게 상정하고 전체 이동 횟수가 4n을 넘어가면 -1을 반환하도록 했습니다.(n<=300,000 이기 때문에 3n이나 4n이나 별 차이가 없어서 다른 예외 경우도 생각해 4n으로 설정했습니다.) 구현 자체는 쉽게 진행했네요.

## 🔎 Solve
- 첫 번째 큐에 각 숫자들을 넣어주면서 합을 구합니다. 만일 특정 값이 기존의 최댓값보다 크다면 최댓값을 갱신합니다.
- 두 번째 큐에 각 숫자들을 넣어주면서 합을 구합니다. 만일 특정 값이 기존의 최댓값보다 크다면 최댓값을 갱신합니다.
- 전체 합이 홀수거나 숫자의 최댓값이 합의 절반보다 크면 -1을 반환합니다.
- 두 큐의 합이 같을 때까지 숫자들을 요리조리 움직입니다.
  - 합1이 합2보다 크면 합1에서 첫 번째 큐의 첫 번째 값만큼 빼고, 합2에 그만큼의 값을 더합니다. 이 때, 실제로 큐의 숫자들도 이동시킵니다.
  - 합2가 합1보다 크면 합2에서 두 번째 큐의 첫 번째 값만큼 빼고, 합1에 그만큼의 값을 더합니다. 이 때, 실제로 큐의 숫자들도 이동시킵니다.
- 만일 전체 이동 횟수가 큐의 길이 * 4를 초과하면 -1을 반환합니다.
