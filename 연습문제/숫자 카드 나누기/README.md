#### 🔗 Link

https://school.programmers.co.kr/learn/courses/30/lessons/135807

## 🤔 Think
 사실 어려운 문제는 아닙니다. 다만 한 가지 주의해야 할 점은 약수를 구하는 방법입니다.

 숫자가 1억까지 존재하기 때문에 단순히 1부터 전부 돌면서 약수의 리스트를 구하면 효율성면에서 문제가 발생할 수밖에 없습니다. O(N)밖에 안되는데 1억 개를 모두 뒤져봐야 하거든요.

 대신, √n 까지만 탐색하면 됩니다. 모든 수의 약수는 √n을 중심으로 양 쪽으로 퍼져있는 형태니까요. 만일 제곱 수라면 √n이 정수 형태로 나올테니 마지막으로 하나가 추가될겁니다.

 당연히 주어진 배열의 모든 숫자의 약수들을 구할 필요도 없습니다. 어짜피 한 숫자에서의 약수로 다른 모든 숫자들이 나누어 떨어져야하니까요.

## 🔎 Solve
- 주어진 배열들에서 각 배열의 최솟값을 찾습니다.
- 해당 최솟값들의 약수 리스트를 만듭니다.
  - 이 때 √n까지만 탐색해 시간복잡도를 O(logN)으로 줄입니다.
- 만들어진 약수 리스트 중 다른 수들도 모두 나누어떨어지는 약수만 따로 걸러냅니다.
  - 이 때, 최댓값을 구해야하므로 역순 우선순위 큐를 사용합니다.
- 만들어진 우선순위 큐에서 하나씩 pop해가며 반대편 배열의 모든 수가 나누어 떨어지지 않는지 검증합니다.
  - 만일 모든 수가 나누어 떨어지지 않고, 기존의 answer값보다 크다면 answer를 대체합니다.
