#### 🔗 Link

https://school.programmers.co.kr/learn/courses/30/lessons/152996


## 🤔 Think
 핵심은 어떻게 O(N)을 만들 것이냐? 였습니다. 주어지는 배열이 10만 개가 되면 O(N^2)부터는 무조건 시간초과가 날 수밖에 없었거든요.

 그런데, 문제를 슥 보면 O(N^2)밖에 안될 것 같습니다. A의 짝꿍을 나머지 전체에서 찾아야 하거든요. 저는 이렇게 시간초과가 안될 것 같은 방법밖에 없다 싶으면 동적 프로그래밍 문제가 아닌가 생각해봅니다.

 일단 짝꿍 숫자들을 전부 찾아내는 것까지는 쉽게 생각해낼 수 있습니다. 문제는 그래서 어떻게 O(N)으로 줄이냐는 것인데, 여기서 동적 프로그래밍의 개념이 들어갑니다.

 동적 프로그래밍의 핵심은 하나하나 지나갈 때마다 새롭게 무언가가 갱신되어야한다는 것입니다. 어떤 동적 프로그래밍 문제를 풀어도 마찬가지입니다. 한 원소를 지나가면 무조건 뭔가 갱신됩니다.

 여기서 힌트를 얻었습니다. n번이 n+1번부터 자신의 짝꿍을 찾는게 아니라, 1~n-1번 까지 중에 자기 짝꿍은 몇 명있는지를 찾아야 하는거죠. 여기까지 도달하면 문제를 쉽게 풀 수 있습니다.

## 🔎 Solve
- <n : n의 짝꿍들> 형태의 map(짝꿍 맵)을 만듭니다.
- <특정 숫자 : 등장 횟수> 형태의 map(횟수 맵)을 만듭니다.
- weights 배열을 순회하며 n번째 숫자의 짝꿍 숫자를 찾아 두 맵을 채웁니다.
  - 정수의 형태만 가능하다는 점에 유의하며 맵을 채워야합니다.
- 다시 weights 을 순회하며 n번째 숫자의 짝꿍 숫자가 등장한 횟수만큼 answer에 더해줍니다.
- 더해주는 작업이 끝나면, 횟수 맵에서 n번째 숫자의 등장 횟수를 1 증가시켜줍니다.
  - 미리 더해주면, 정답에 weights의 길이만큼의 값이 더해집니다.
