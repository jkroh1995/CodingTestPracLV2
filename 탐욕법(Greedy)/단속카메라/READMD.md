#### 🔗 Link

﻿https://school.programmers.co.kr/learn/courses/30/lessons/42884

## 🤔 Think 
 그리디 문제는 언제 풀어도 쉽지가 않네요. 이번 문제 역시 마찬가지였습니다.

 일단 진입 시점을 기준으로 정렬하는 것까지는 쉽게 예상하실 수 있습니다. 그럼 비교를 어디로 할거냐를 생각해야 합니다.

 첫 번째 경로를 시작으로 해당 경로내에서 특정 경로를 같이 감시할 수 있다면 다음 번에 해당 경로를 무시해도 된다는 점이 포인트입니다. 일단 이중 for문을 쓰겠네요. i 번째를 기준으로 i+1번째부터 다시 for문을 돌면서, 감시 범위 내에 있으면 해당 범위는 무시해도 된다는 check point를 남겨놔야겠습니다.

 i 번을 시작으로 i+1, i+2, ... n까지 돌면서 만약에 i번의 종료 지점보다 n번의 시작지점이 작거나 같다면 해당 지점은 함께 감시됩니다. 첫 번째 반복문의 마지막에는 카메라를 하나 더해줍니다.

 다음 i+1번부터 시작했을 때, 만일 해당 지점이 감시 포인트 내에 있다면 첫 번째 for문을 continue하면 카메라를 더하는 부분을 생략합니다. 어짜피 해당 부분은 i번째, 혹은 그 전에 감시 가능한 지역이니까요.

## 🔎 Solve
- 시작 지점으로 정렬하기 위해 Comparable을 구현한 Route클래스를 사용합니다.
- 감시 가능한 지점을 저장하기 위한 boolean 타입 배열을 선언합니다.
- 이중 for문을 순회하며 답을 구합니다.
  - 첫 번째 for문을 시작할 때, 만일 i 번째 경로가 카메라 경로 내에 있다면 넘어갑니다.
  - 그렇지 않다면 해당 경로 이후의 경로들 중 카메라 범위 내에 포함될 수 있는 경로들을 boolean 배열에 표시합니다.
  - 넘어가지 않은 경로는 카메라에 포함되어 있지 않기 때문에 카메라를 하나 더합니다.
