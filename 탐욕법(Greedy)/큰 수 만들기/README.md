#### 🔗 Link

https://school.programmers.co.kr/learn/courses/30/lessons/42746

## 🤔 Think
 개인적으로 그리디  문제는 동적 프로그래밍 문제와 함께 상당히 해결하기 어렵게 느껴집니다. 이 문제도 마찬가지로 오랜 기간 해결에 어려움을 겪었고, 다른 분들의 풀이를 보고 해결했네요.

 아마 이 문제를 풀어보시고, 통과하지 못하셨던 분들이 공통적으로 겪는 어려움은 효율성일 것입니다. 저 역시 정확성에서는 문제가 없었는데, 효율성에서 어려움을 겪었고요.

 핵심은 두 가지입니다. 9를 만나면 그 즉시 정답 문자열에 더한다. 만들어야 하는 숫자의 길이보다 하나 작은 길이만큼은 남겨두고 살펴본다.

 가장 큰 수를 만들어야하니 9를 만나면 당연히 바로 더하고 끝내야 할 것입니다. 그런데, 만일 9가 엄청 뒤에 있어서 남은 숫자가 만들어야하는 길이보다 작다면 어떻게 해야할까요. 이를 해결하기 위한 방법이 두 번째 핵심임 숫자를 남겨두는 것입니다.

 숫자를 남겨두는 것은 다른 분들의 질문에서 인사이트를 얻었습니다. 예를 들어서, 아홉 자리 숫자로 다섯 자리 숫자를 만들어야하면 뒤에 네 자리는 남겨두고 앞에 다섯 자리에서 최댓값을 구하는 것이죠.

 예를 들어, 123459876를 가지고 만들 수 있는 가장 큰 다섯 자리 수는 59876이죠. 뒤에 네 자리를 남겨두고 12345만 살펴보면, 가장 큰 수가 5입니다. 다른 어떤 수를 사용해도 59876보다는 크게 만들 수 없습니다.

## 🔎 Solve
- 만들어야 하는 길이만큼 숫자를 붙이기 때문에, 그만큼 반복해줍니다.
- 이중 for 문은 시작하는 index부터 k + i 번 index까지 문자열을 순회하며, 가장 큰 숫자를 찾습니다.
  - 이 때, k + i 가 되는 이유는 다음과 같습니다.
    - 전체 길이가 n, 빼는 숫자의 갯수는 k + i 개 입니다. 숫자를 정답에 더할 때마다, 빼야되는 숫자의 갯수도 그만큼 늘어납니다.
    - 구해야 되는 숫자의 길이는 n - k - i가 됩니다. 남겨놔야 되는 숫자의 갯수는 n - k - i - 1이 됩니다. 
    - 즉, 탐색해야 하는 범위는 n - (n - k - i - 1) = n - n + k - i + 1 = k + i + 1개입니다.
    - 이를 index로 표현하면, k + i 가 됩니다.
  - index는 k + i 까지 순회하고, i 는 계속 1씩 늘어나니 반복문이 무너질 일은 없습니다.
  - 만일 9를 만나면, index를 바꾸고 정답에 9를 더한 뒤, 반복문을 종료합니다.
